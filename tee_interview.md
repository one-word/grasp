# C++基础

## 1.指针与引用的区别

C++ 中指针和引用是两个不同的概念，尽管它们都是用来处理内存中的地址。

指针是一个变量，它存储了一个内存地址，该地址指向内存中的一个值。指针可以被初始化、赋值、解引用和修改指向的地址，还可以进行指针运算。指针需要使用运算符“*”来访问它所指向的值。

引用是一个别名，它给一个已存在的变量起了一个新名字，使用它可以通过原变量名或别名来访问变量的值。引用必须在定义时进行初始化，并且一旦绑定了一个变量，就不能再绑定到其他变量上。因此，引用相比指针更安全，也更容易理解和使用。

以下是指针和引用的区别：

指针可以为NULL，表示指向的是无效地址，而引用必须引用一个已经存在的变量。
指针可以在定义后不进行初始化，而引用必须在定义时进行初始化。
指针可以在运行时修改指向的地址，而引用一旦绑定了一个变量，就不能再绑定到其他变量上。
指针可以进行指针运算，而引用不能进行运算。
指针的类型可以是任意类型，而引用必须和原变量的类型相同。
因此，如果你需要在程序中修改变量的值或者需要通过传递参数来改变变量的值，可以使用指针；如果你只需要引用变量的值而不需要修改它，可以使用引用。

## 2.移动构造函数与拷贝构造函数对比

C++中的移动构造函数和拷贝构造函数都是用于对象的构造。它们之间的主要区别在于如何处理资源（比如堆内存、文件句柄等）的所有权。下面是它们之间的对比：

拷贝构造函数会把一个对象的资源复制到另一个对象中，而移动构造函数会把一个对象的资源转移给另一个对象，这样就避免了资源复制的开销。
拷贝构造函数的参数通常是一个 const 引用，而移动构造函数的参数是一个右值引用（&&）。
移动构造函数比拷贝构造函数更加高效，因为它只需要对指针进行赋值操作，而不需要对资源进行拷贝。在处理大型对象或对象数量较多时，使用移动构造函数可以大大提高程序的性能。
如果没有定义移动构造函数，编译器会自动生成一个默认的拷贝构造函数。但如果定义了移动构造函数，编译器不会自动生成默认的移动构造函数。
总之，拷贝构造函数和移动构造函数都是 C++ 中非常重要的概念，掌握它们之间的区别有助于写出更高效的代码。

## 3.四种智能指针及底层实现：auto_ptr、unique_ptr、shared_ptr、weak_ptr

在C++中，指针是一种常用的数据类型，用于在内存中存储对象的地址。智能指针是一种特殊的指针类型，它们可以自动管理所指向的对象的生命周期，从而避免内存泄漏等问题。

下面是四种常见的智能指针类型及其底层实现：

auto_ptr：是C++98标准中提供的一种智能指针，被unique_ptr取代，不推荐使用。auto_ptr中封装了一个指向对象的裸指针，并提供了一些成员函数来管理对象的生命周期，例如析构函数和拷贝构造函数。auto_ptr没有提供引用计数机制，因此不能实现共享所有权的指针。

unique_ptr：是C++11标准中引入的一种智能指针，用于管理独占所有权的指针。unique_ptr中封装了一个指向对象的裸指针，并使用了移动语义来管理对象的生命周期，从而避免了拷贝构造函数和拷贝赋值运算符的调用。unique_ptr还提供了reset()函数来释放资源，并支持自定义删除器。

shared_ptr：也是C++11标准中引入的一种智能指针，用于管理共享所有权的指针。shared_ptr中维护了一个引用计数器，用于记录当前有多少个shared_ptr指向同一个对象。当引用计数器减为0时，对象才会被销毁。shared_ptr使用引用计数机制来实现多个指针共享对象所有权的功能。

weak_ptr：也是C++11标准中引入的一种智能指针，用于管理弱引用的指针。weak_ptr是shared_ptr的一种辅助类型，用于解决shared_ptr中的循环引用问题。weak_ptr可以通过lock()函数获取一个shared_ptr对象，从而访问被管理的对象，但不会增加引用计数器。

需要注意的是，以上四种智能指针都是基于模板类实现的，可以支持不同类型的对象。同时，它们也都是标准库中定义的类，可以在头文件< memory >中找到它们的定义。

## 4.右值引用

C++11引入了右值引用（rvalue reference）的概念，是对左值引用的一种扩展。在C++中，左值是指有名称、有地址、可寻址的对象，而右值是指不具有地址，只有值的临时对象或表达式。

右值引用的语法是使用“&&”符号，如下所示：

python
Copy code
int&& rvalue = 42;
右值引用有两个主要用途：移动语义和完美转发。

移动语义（move semantics）通过转移资源所有权来提高代码的效率，避免不必要的复制。右值引用可以绑定到临时对象，然后将其所有权转移给另一个对象，从而避免复制和销毁临时对象。

完美转发（perfect forwarding）用于在函数模板中传递参数。右值引用可以将参数转发给其他函数，使其保持原来的类型和值分类。这样可以避免不必要的类型转换和复制。

## 5.std::move函数

std::move() 是 C++ 11 中引入的一个函数，位于 `<utility>`头文件中。它提供了一种将左值强制转换为右值引用的方式。

在 C++ 中，左值引用表示对一个具有名称的对象的引用，而右值引用则表示对一个临时对象的引用。由于临时对象的生命周期通常只在表达式的求值期间，因此将其转换为右值引用，可以避免在复制和析构操作中进行不必要的拷贝和内存分配，从而提高程序的性能。

std::move() 可以将一个左值强制转换为右值引用，以便利用移动语义来实现高效的数据交换。具体来说，std::move() 将左值转换为右值引用，这意味着该对象的所有权被转移，它的值可以在不进行拷贝的情况下传递到函数中，或者用于初始化另一个对象。

需要注意的是，使用 std::move() 时必须保证移动操作不会对程序的正确性产生任何影响。因为使用 std::move() 后，源对象的值会被“窃取”，它将不再保持原有的状态。

## 6.迭代器原理与迭代器失效问题

迭代器是一种用于遍历容器元素的对象。迭代器的实现方式是，定义一个类（或者结构体）来封装指向容器元素的指针，并提供相应的方法来实现对容器的遍历。迭代器分为正向迭代器和双向迭代器，其中正向迭代器只能往前遍历，而双向迭代器可以往前或往后遍历。

迭代器失效是指，在容器元素被修改或者被删除时，原本指向这些元素的迭代器变得不再可用。这种情况可能会导致程序出现未定义的行为。例如，在使用 vector 容器时，如果使用指向容器元素的迭代器来访问一个已经被删除的元素，就可能会导致程序崩溃或者出现其他异常情况。

为了避免迭代器失效问题，可以采用以下策略：

遍历容器时，尽量避免在容器内部进行修改或者删除元素的操作。
如果需要修改容器中的元素，可以先将要修改的元素复制到一个临时变量中，并在修改完毕后再将其赋值回原位置。
如果需要在遍历中删除元素，可以使用迭代器的 erase() 方法删除元素，并将迭代器移动到下一个位置。注意，erase() 方法会返回下一个元素的迭代器，因此需要将其保存下来以防止迭代器失效。

## 7.一些重要的 STL：vector, list, map, set介绍

STL（Standard Template Library）是C++的一个标准库，提供了许多常用的数据结构和算法。其中，vector、list、map、set是STL中最常用的四种容器类型。

vector（向量）：
vector是一种动态数组，能够根据需要动态地分配内存空间，支持快速的随机访问。vector中的元素在内存中是连续存放的，因此可以利用CPU的缓存机制进行快速访问。vector还提供了一些成员函数，如push_back、pop_back等，用于在尾部插入和删除元素。

list（链表）：
list是一种双向链表，能够在任意位置高效地插入和删除元素，但不支持随机访问。list的迭代器支持双向移动，并提供了一些成员函数，如push_front、pop_front等，用于在头部插入和删除元素。

map（映射）：
map是一种键值对映射，它将每个键映射到一个唯一的值。map的实现使用了红黑树，能够高效地支持查找、插入和删除操作。map的迭代器支持双向移动，并提供了一些成员函数，如insert、erase等，用于插入和删除元素。

set（集合）：
set是一种用于存储不重复元素的容器，支持高效地插入、删除和查找操作。set的实现使用了红黑树，能够保证元素有序。set的迭代器支持双向移动，并提供了一些成员函数，如insert、erase等，用于插入和删除元素。

总之，vector、list、map、set是STL中最基本、最常用的容器类型，可以方便地处理各种数据结构问题。在使用STL容器时，应根据实际问题的需要选择合适的容器类型，并注意避免迭代器失效等问题。

## 8.容器对比，map 与 unordered_map 对比，set 与 unordered_set 对比，vector 与 list 对比

STL中的容器可以根据其内部实现的不同分为多种不同的类型，其中一些重要的容器包括vector、list、map和set。在这些容器中，有些具有类似的特征和用途，而有些则具有不同的特征和用途，下面对其中几种进行简要介绍和对比。

vector和list
vector和list都是线性容器，都支持快速的随机访问和顺序访问。二者的主要区别在于底层实现机制不同，vector使用数组来实现，而list使用链表来实现。因此，vector在执行随机访问操作时速度快，但在执行插入和删除操作时速度较慢，而list在执行插入和删除操作时速度快，但在执行随机访问操作时速度较慢。

map和set
map和set都是关联容器，都可以按照键值进行访问和操作。map用于存储键值对，可以根据键来查找对应的值；而set只用于存储值，且值必须是唯一的。二者的主要区别在于底层实现机制不同，map使用红黑树来实现，而set也使用红黑树来实现，但只存储键或值。

unordered_map和unordered_set
unordered_map和unordered_set是STL中C++11新增的关联容器，也可以按照键值进行访问和操作，但它们的底层实现机制不同于map和set，它们使用哈希表来实现，具有更快的查找速度，但是对于内存的使用和处理较为苛刻，插入、删除等操作也更加消耗时间。

总的来说，vector、list、map、set等STL容器各有特点，开发者可以根据不同的需求选择适合的容器来使用。在实际开发中，应该根据实际情况进行具体的优化选择，例如在需要快速随机访问的场景中可以选择vector，而在需要频繁插入删除的场景中可以选择list。而unordered_map和unordered_set则适合在需要快速查找的场景中使用。

## 9.STL容器空间配置器

STL的容器在使用时需要分配内存来存储元素，而STL使用了一个叫做空间配置器（allocator）的机制来进行内存分配和释放。空间配置器主要负责以下几个任务：

内存分配：根据需要分配足够大小的内存。
内存释放：在容器元素不再使用时，释放对应的内存。
构造对象：在分配内存后，对容器元素进行构造操作。
销毁对象：在释放内存前，对容器元素进行析构操作。
每个STL容器都有默认的空间配置器，但是也可以使用自定义的空间配置器，只需要实现对应的接口即可。

在不同的容器中，由于数据结构和内存管理的方式不同，对于空间配置器的实现也有所区别。例如，vector和list的空间配置器的实现方式就不同，vector的空间配置器需要支持连续的内存块，而list则不需要。因此，在选择容器时，需要考虑其空间配置器的实现方式是否满足要求。

# 计算机网络

## 10.DNS原理以及应用

DNS（Domain Name System）是一种将域名转换为 IP 地址的分布式数据库系统。它通过将域名解析为与之相应的 IP 地址来帮助用户在互联网上访问特定的网站或服务。

DNS 工作原理如下：

用户在浏览器中输入 URL。

系统首先查找本地缓存，如果找到匹配的 IP 地址，则直接返回。

如果在本地缓存中没有找到，系统会向本地 DNS 服务器发出查询请求。

如果本地 DNS 服务器也无法处理该请求，则会将请求转发给根 DNS 服务器。

根 DNS 服务器会返回顶级域名服务器的地址。

本地 DNS 服务器会向顶级域名服务器发送请求。

顶级域名服务器会返回二级域名服务器的地址。

本地 DNS 服务器会向二级域名服务器发送请求。

二级域名服务器会返回 IP 地址。

本地 DNS 服务器将 IP 地址返回给用户。

DNS 的应用非常广泛，几乎所有互联网服务都需要使用 DNS 来解析域名。例如，当你在浏览器中输入网址时，DNS 将该网址转换为相应的 IP 地址，使得浏览器可以连接到服务器并加载网页。此外，DNS 还可以用于负载均衡、反向代理、邮件服务等。

## 11.数字证书，对称加密与非对称加密

数字证书、对称加密和非对称加密都是网络安全中的重要概念，它们分别用于保护数据的机密性和验证数据的真实性。下面是它们的简要介绍：

数字证书
数字证书是一种用于证明数字实体身份的电子文档。它是由一家受信任的第三方机构（如证书颁发机构）签发的，并包含了该实体的公钥、一些标识信息以及该证书的有效期等内容。数字证书可以用于建立安全的网络连接，如HTTPS。

对称加密
对称加密是一种加密方式，它使用同一个密钥来加密和解密数据。发送方使用该密钥对数据进行加密，接收方使用相同的密钥来解密数据。对称加密的主要优点是速度快，但缺点是密钥的管理比较困难。

非对称加密
非对称加密是一种加密方式，它使用一对密钥来加密和解密数据，这对密钥包括一个公钥和一个私钥。发送方使用接收方的公钥对数据进行加密，接收方使用自己的私钥来解密数据。非对称加密的主要优点是安全性高，但缺点是速度比对称加密慢。

在实际应用中，数字证书通常用于验证数据的真实性，而对称加密和非对称加密则用于保护数据的机密性。通常情况下，对称加密用于加密数据，而非对称加密用于保护对称密钥的传输安全。例如，在HTTPS中，服务器使用自己的私钥来对称加密传输的数据进行解密，而浏览器使用服务器的公钥来加密对称密钥的传输。

## 12.输入一个URL到显示页面的流程

将输入一个URL到显示页面的流程简单地描述如下：

用户输入URL（Uniform Resource Locator，统一资源定位符）。
客户端通过DNS解析获取服务器的IP地址。
客户端与服务器建立TCP连接，发送HTTP请求。
服务器接收到请求后，处理并返回HTTP响应。
客户端接收到响应后，解析HTML、CSS、JavaScript等资源，并通过浏览器渲染引擎呈现给用户。
具体过程如下：

用户在浏览器地址栏中输入URL，包括协议、域名和路径等信息，比如http://www.example.com/index.html。
浏览器向本地DNS服务器发送一个查询请求，请求服务器的IP地址。
本地DNS服务器查询缓存中是否存在该域名的IP地址，如果没有则向根域名服务器发送请求，根域名服务器返回下一级DNS服务器的地址。
本地DNS服务器向下一级DNS服务器发送请求，直到找到对应域名的IP地址。然后将IP地址返回给浏览器。
浏览器向服务器的IP地址建立TCP连接，发送HTTP请求，请求资源，比如index.html。
服务器接收到请求后，处理请求，查找请求的资源，比如index.html，并返回HTTP响应，包括响应码、响应头、响应正文等信息。
浏览器接收到响应后，根据响应头信息判断响应正文的类型（HTML、CSS、JavaScript等），然后解析响应正文，构建DOM树和CSSOM树，然后进行布局计算、绘制等操作。
渲染引擎将解析后的文档呈现给用户。

# 操作系统

## 13.线程同步的方式：互斥锁、自旋锁、读写锁、条件变量

在多线程并发编程中，为了保证数据的正确性和可靠性，需要进行线程同步。常见的线程同步方式包括：

互斥量（Mutex）：通过对共享资源加锁的方式，保证同一时间只有一个线程可以访问共享资源。互斥量需要考虑死锁问题，因此需要合理地设计锁的粒度和避免锁的嵌套使用。

信号量（Semaphore）：和互斥量类似，但是信号量可以控制多个线程同时访问共享资源的数量，可以用于解决生产者消费者问题等并发场景。

条件变量（Condition Variable）：用于等待某个条件成立的线程等待唤醒，可以和互斥量一起使用，避免线程忙等待。

屏障（Barrier）：用于多个线程等待彼此达到某个特定点再同时执行后续操作，常用于并行计算等场景。

原子操作（Atomic）：使用原子操作可以避免多个线程同时对同一变量进行操作时的数据竞争问题，常用于计数器等场景。

读写锁（Read-Write Lock）：在读多写少的场景下，使用读写锁可以提高并发性能，允许多个线程同时读取共享资源，但是只允许一个线程进行写入操作。

无锁（Lock-Free）：使用无锁编程技术，避免使用锁带来的竞争和延迟问题，但是需要考虑更复杂的并发问题，如ABA问题等。

不同的线程同步方式在实现和性能上都有所差异，需要根据具体的并发场景和需求进行选择。

## 14.互斥锁与自旋锁的底层区别

互斥锁和自旋锁都是线程同步机制中常用的锁。它们的底层实现机制略有不同。

互斥锁(Mutex)是一种常用的锁，它可以确保线程独占资源，一次只有一个线程可以拥有锁，其他线程必须等待锁的释放。当一个线程加锁时，如果锁被其他线程持有，线程会被挂起并进入阻塞状态，等待锁的释放。

互斥锁的实现通常涉及系统调用，即操作系统内核提供的系统级别的原语，因此效率较低。在互斥锁的实现中，加锁和解锁操作涉及到了用户态和内核态之间的切换，这种切换对系统的性能有很大的影响。

自旋锁(Spin Lock)是一种基于忙等待的锁。当一个线程尝试获取自旋锁失败时，它并不会立即进入阻塞状态，而是进入一个忙等待的循环中，不断地检查自旋锁的状态，直到获取到锁。如果在自旋等待期间，其他线程释放了锁，那么该线程就可以立即获取锁而不必等待操作系统内核的调度。

自旋锁通常比互斥锁的效率高，因为自旋锁的加锁和解锁操作都是在用户态完成的，避免了用户态和内核态之间的切换。

在底层实现上，互斥锁通常使用了系统调用来实现锁的操作，而自旋锁则使用了CPU的特殊指令实现锁的操作。自旋锁的实现依赖于CPU的硬件支持，因此在不同的CPU上，自旋锁的效率可能有所不同。

## 15.孤儿进程与僵尸进程

孤儿进程（orphan process）指的是父进程先于子进程退出，并且子进程还在运行的情况下，这时候子进程就成为了孤儿进程，孤儿进程会被init进程（PID为1的进程，通常是系统启动时第一个被启动的进程）收养，成为其子进程。收养之后，init进程会负责回收孤儿进程的资源。所以，孤儿进程不会导致系统出现资源泄露等问题。

僵尸进程（zombie process）指的是已经完成了自己的工作，但是其父进程尚未将其彻底回收的进程。在系统中，进程完成工作后并不会立即退出，而是进入等待状态，等待父进程回收它的资源。如果父进程没有及时回收，那么这个进程就会变成僵尸进程，占用系统资源，而且无法通过ps命令查看进程信息。当出现大量僵尸进程时，系统的资源就会被耗尽。

因此，及时回收孤儿进程和僵尸进程是很重要的，可以通过wait、waitpid等系统调用来实现。如果父进程没有及时回收子进程，可以使用kill命令来终止该子进程，释放其占用的资源。

## 16.进程间通信：PIPE、FIFO、消息队列、信号量、共享内存、socket

进程间通信是指不同进程之间进行信息交换和共享资源的方式。以下是常见的进程间通信方式：

管道：管道是一种半双工的通信方式，只能在具有亲缘关系的进程之间使用，比如父子进程。管道可以是匿名的无名管道，也可以是有名管道。

共享内存：共享内存是指两个或多个进程共享一个给定的存储区域，进程可以直接访问共享内存中的数据，是一种高效的进程间通信方式。

信号量：信号量是一种计数器，用来保持多个进程对共享资源的访问，进程间通过对信号量进行操作来实现同步和互斥。

消息队列：消息队列是一个消息链表，进程可以向队列中写入消息，另一个进程可以从队列中读取消息。消息队列是一种可靠的进程间通信方式。

套接字：套接字是一种网络编程中常用的通信方式，通过网络传输数据，可以实现不同主机之间的进程通信。

## 17.死锁及避免

死锁是指两个或多个进程或线程，在执行过程中，因争夺资源而造成的一种僵局，互相等待对方的资源，而导致所有进程或线程都无法继续执行下去的现象。

死锁的发生必须同时满足以下四个条件，也称为死锁的四个必要条件：

互斥条件：至少有一个资源处于非共享模式，即一次只允许一个进程使用，其他进程需要等待。

请求与保持条件：进程已经持有了至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程被阻塞，但又对自己已经获得的资源保持不放。

不可剥夺条件：进程已经获得的资源，在未使用完之前，不能被其他进程强行剥夺，只能由自己释放。

循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。

避免死锁的方法有以下几种：

破坏互斥条件：允许多个进程或线程同时访问某些资源，这些资源是非独占的。

破坏请求与保持条件：一次性获取所有需要的资源，或者当进程无法获取所需资源时，释放已经获得的资源，等待资源获取后再重新申请。

破坏不可剥夺条件：强制剥夺某些进程已经占有的资源。

破坏循环等待条件：对资源进行排序，按照一定的顺序请求资源，避免循环等待。

实际应用中，死锁的避免往往采用多种方法的组合，例如，操作系统中的资源分配和回收策略，多线程编程中的锁设计等。

## 18.进程的调度算法



## 19.阻塞IO与非阻塞IO

阻塞 I/O 和非阻塞 I/O 是 I/O 编程中的两个重要概念。

在传统的阻塞式 I/O 中，当程序向内核请求读取数据时，如果数据还没有准备好，内核将使进程进入休眠状态，直到数据准备好为止，然后内核再将数据拷贝到进程的缓冲区中，最后进程才解除阻塞状态并继续执行。同样的，在传统的阻塞式 I/O 中，当程序向内核写入数据时，如果内核的输出缓冲区已满，那么内核将使进程进入阻塞状态，直到缓冲区有足够的空间来容纳待写入的数据，然后进程才解除阻塞状态并继续执行。

在非阻塞式 I/O 中，进程向内核发出 I/O 请求之后，并不会阻塞等待 I/O 完成，而是立即返回并继续执行其他操作。此时，内核会立即返回一个错误码，告诉进程当前 I/O 操作是非阻塞的，并且内核会不断地检查 I/O 操作是否完成。因此，进程需要不断地查询 I/O 操作的状态，直到操作完成为止。

非阻塞 I/O 可以通过循环查询 I/O 操作状态的方式来实现异步 I/O。在异步 I/O 中，进程向内核发出 I/O 请求之后，内核会立即返回，并在 I/O 完成后通知进程。这种方式可以让进程在等待 I/O 完成的同时继续执行其他操作，从而提高系统的并发性能。

## 20.虚拟内存概念

虚拟内存是一种操作系统的内存管理技术，它允许进程访问虚拟地址空间，而不是物理地址空间。每个进程都认为自己拥有整个系统的物理内存，但实际上只有被需要的部分才会被加载到物理内存中。

虚拟内存的实现依靠硬件和操作系统的配合。当进程访问虚拟地址时，CPU会将其转化为对应的物理地址。如果该地址已经被缓存在物理内存中，那么操作就可以直接进行；否则，操作系统会将相应的物理页从磁盘中加载到物理内存中，并更新页表中的映射关系。

虚拟内存的主要作用是：

提供了比物理内存更大的虚拟地址空间，使得多个进程可以共享物理内存，从而实现了更高效的内存利用。

允许进程访问不在物理内存中的数据，从而避免了物理内存的限制。

实现了内存保护机制，防止进程访问未经授权的内存区域。

实现了内存共享机制，使得进程可以共享同一块物理内存，从而提高了进程间的通信效率。

虚拟内存的缺点是：

由于需要在磁盘和物理内存之间频繁地交换数据，因此会造成一定的性能损失。

需要占用一定的磁盘空间，因为虚拟内存中的数据可能需要被换入和换出。

由于操作系统需要维护虚拟内存和物理内存之间的映射关系，因此会占用一定的系统资源。

## 21.MMU地址翻译的具体流程

## 22.缺页处理过程

## 23.缺页置换算法：最久未使用算法、先进先出算法、最佳置换算法

# mysql

## 24.索引相关：索引是如何实现的？多种引擎的实现区别？聚族索引，非聚族索引，二级索引，唯一索引、最左匹配原则等等

## 25.事务相关：例如事务的隔离是如何实现的？事务是如何保证原子性？不同的事务看到的数据怎么就不一样了？难道每个事务都拷贝一份视图？MVCC 的实现原理

## 26.各种锁相关：例如表锁，行锁，间隙锁，共享锁，排他锁。这些锁的出现主要是用来解决哪些问题？

## 27.日志相关：redolog，binlog，undolog，这些日志的实现原理，为了解决怎么问题？

# 网络编程

## 28.IO多路复用：select、poll、epoll的区别

select、poll 和 epoll 都是 Linux 中实现 IO 多路复用的机制。它们的主要作用是允许单个进程同时监视多个文件描述符，从而实现同时等待多个 IO 操作的完成。

它们之间的主要区别如下：

select 和 poll 适合于少量文件描述符的 IO 多路复用，当文件描述符较多时，时间复杂度为 $O(n)$，效率较低，因为每次调用 select 或 poll 都需要将所有监视的文件描述符从用户空间复制到内核空间。

epoll 适用于大量文件描述符的 IO 多路复用，当文件描述符较多时，效率更高，因为每次调用 epoll_wait 都只需要复制发生变化的文件描述符，不需要复制全部文件描述符。此外，epoll 还支持 Edge Triggered (ET) 和 Level Triggered (LT) 两种模式，ET 模式比 LT 模式更高效。

select 和 poll 通过轮询的方式查找就绪的文件描述符，而 epoll 利用了 Linux 内核提供的回调机制，将就绪的文件描述符添加到就绪队列中，因此效率更高。

总之，select、poll 和 epoll 都是实现 IO 多路复用的机制，它们的主要区别在于适用场景和效率。epoll 是 Linux 下最为常用的 IO 多路复用机制。

## 29.基于事件驱动的reactor模式

基于事件驱动的Reactor模式是一种常用于高性能网络编程的设计模式。它的核心思想是将网络I/O的读写操作放到主线程之外，交给专门的I/O线程或者线程池来处理，从而实现高并发和高性能。

Reactor模式的基本原理是：I/O线程通过事件监听机制（如epoll）来监控文件描述符（如socket），当有事件发生时，由I/O线程进行读写操作，而业务处理逻辑则由主线程或者其他线程进行处理。当有大量客户端连接时，Reactor模式可以通过I/O线程池来处理客户端连接，从而实现高并发处理。

Reactor模式的主要特点包括：

事件驱动：I/O线程通过事件监听机制来监控文件描述符，当有事件发生时，由I/O线程进行读写操作。
非阻塞I/O：I/O线程采用非阻塞I/O方式来进行读写操作，避免了线程阻塞等待I/O完成的情况。
多路复用：通过I/O线程池来处理大量的客户端连接，提高了系统的并发处理能力。
任务分离：将I/O线程和业务处理线程分离，使得系统具有更好的可扩展性和可维护性。
总的来说，基于事件驱动的Reactor模式是一种高性能、高并发、可扩展、可维护的网络编程模式，适用于对高性能、高并发有要求的网络应用程序。